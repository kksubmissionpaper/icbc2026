module abort_test::taxonomy {
    use sui::coin::{Self, Coin};
    use sui::sui::SUI;
    use sui::balance::{Self, Balance};

    // ========================================
    // Error Code Taxonomy
    // ========================================
    
    // Language Level (Developer-defined)
    const E_VALUE_TOO_SMALL: u64 = 100;
    const E_VALUE_TOO_LARGE: u64 = 101;
    const E_INVALID_STATE: u64 = 102;
    const E_INSUFFICIENT_BALANCE: u64 = 103;
    const E_UNAUTHORIZED: u64 = 104;
    
    // VM Level (Will be caught by Move VM)
    // (No explicit constants - these are implicit)
    // - Arithmetic overflow/underflow
    // - Division by zero
    // - Vector out of bounds
    
    // Runtime Level (Sui-specific)
    // (Caught by Sui runtime, not in contract)
    // - Object ownership violation
    // - Shared object lock conflict
    // - Type mismatch

    // ========================================
    // Test Objects
    // ========================================
    
    public struct TestObject has key, store {
        id: UID,
        value: u64,
        balance: Balance<SUI>
    }
    
    public struct OwnerCap has key, store {
        id: UID,
        for_object: ID
    }
    
    public struct AdminCap has key, store {
        id: UID,
        admin_level: u8
    }

    // ========================================
    // Category 1: Language-Level Errors
    // (Explicit assert! with custom error codes)
    // ========================================
    
    /// Test single assertion (E_VALUE_TOO_SMALL: 100)
    public fun test_single_assert(value: u64) {
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }
    
    /// Test E_VALUE_TOO_LARGE (101) - NEW!
    public fun test_value_upper_bound(value: u64) {
        assert!(value <= 1000, E_VALUE_TOO_LARGE);
    }
    
    /// Test multiple assertions (which one fails?)
    public fun test_multiple_asserts(
        value1: u64,
        value2: u64,
        value3: u64
    ) {
        assert!(value1 > 10, E_VALUE_TOO_SMALL);
        assert!(value2 < 100, E_VALUE_TOO_LARGE);
        assert!(value3 != 0, E_INVALID_STATE);
    }
    
    /// Test nested function abort propagation
    fun internal_check(value: u64): u64 {
        assert!(value < 1000, E_VALUE_TOO_LARGE);
        value * 2
    }
    
    public fun test_nested_abort(value: u64): u64 {
        internal_check(value)
    }
    
    /// Test range validation (E_VALUE_TOO_SMALL and E_VALUE_TOO_LARGE) - NEW!
    public fun test_value_range(value: u64, min: u64, max: u64) {
        assert!(value >= min, E_VALUE_TOO_SMALL);
        assert!(value <= max, E_VALUE_TOO_LARGE);
    }

    // ========================================
    // Category 2: VM-Level Errors
    // (Move VM catches these)
    // ========================================
    
    /// Arithmetic overflow
    public fun test_overflow(a: u64, b: u64): u64 {
        a + b  // Aborts if a + b > U64_MAX
    }
    
    /// Arithmetic underflow
    public fun test_underflow(a: u64, b: u64): u64 {
        a - b  // Aborts if b > a
    }
    
    /// Division by zero
    public fun test_division_by_zero(a: u64, b: u64): u64 {
        a / b  // Aborts if b == 0
    }
    
    /// Vector out of bounds
    public fun test_vector_oob(index: u64): u64 {
        let vec = vector[10u64, 20u64, 30u64];
        *vector::borrow(&vec, index)  // Aborts if index >= 3
    }
    
    /// Borrow conflict (immutable + mutable)
    public fun test_borrow_conflict(): u64 {
        let mut vec = vector[100u64];
        let _immut_ref = vector::borrow(&vec, 0);
        let _mut_ref = vector::borrow_mut(&mut vec, 0);  // Aborts
        0
    }

    // ========================================
    // Category 3: State Rollback Observation
    // ========================================
    
    /// Create object then abort (object should not exist)
    public fun test_partial_object_creation(
        should_abort: bool,
        ctx: &mut TxContext
    ) {
        // Step 1: Create object
        let obj = TestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero()
        };
        
        // Step 2: Share object
        transfer::share_object(obj);
        
        // Step 3: Conditionally abort
        assert!(!should_abort, E_INVALID_STATE);
        
        // If abort: object creation should be rolled back
    }
    
    /// Modify balance then abort (balance should rollback)
    public fun test_balance_rollback(
        obj: &mut TestObject,
        coin: Coin<SUI>,
        should_abort: bool,
        ctx: &mut TxContext
    ): Coin<SUI> {
        let original_value = balance::value(&obj.balance);
        
        // Add coin to object's balance
        let added = coin::into_balance(coin);
        balance::join(&mut obj.balance, added);
        
        // Check new balance increased
        let new_value = balance::value(&obj.balance);
        assert!(new_value > original_value, E_INVALID_STATE);
        
        // Conditionally abort
        assert!(!should_abort, E_INVALID_STATE);
        
        // If abort: balance should rollback to original
        coin::zero(ctx)  // Return dummy coin
    }

    // ========================================
    // Category 4: Sui-Specific Ownership
    // ========================================
    
    /// Create object with owner capability
    public fun create_owned_object(ctx: &mut TxContext): (TestObject, OwnerCap) {
        let id = object::new(ctx);
        let obj_id = object::uid_to_inner(&id);
        
        let obj = TestObject {
            id,
            value: 0,
            balance: balance::zero()
        };
        
        let cap = OwnerCap {
            id: object::new(ctx),
            for_object: obj_id
        };
        
        (obj, cap)
    }
    
    /// Modify object - requires capability (E_UNAUTHORIZED: 104)
    public fun modify_with_cap(
        obj: &mut TestObject,
        cap: &OwnerCap,
        new_value: u64
    ) {
        // Check capability matches object
        assert!(object::uid_to_inner(&obj.id) == cap.for_object, E_UNAUTHORIZED);
        obj.value = new_value;
    }
    
    /// Attempt to modify without capability (will fail)
    public fun modify_without_cap(
        obj: &mut TestObject,
        new_value: u64
    ) {
        // This should fail at runtime if caller doesn't own obj
        obj.value = new_value;
    }
    
    /// Create admin capability - Returns AdminCap for caller to handle
public fun create_admin_cap(admin_level: u8, ctx: &mut TxContext): AdminCap {
    AdminCap {
        id: object::new(ctx),
        admin_level
    }
}
    
    /// Admin-only operation (E_UNAUTHORIZED: 104) - NEW!
    public fun admin_only_operation(
        cap: &AdminCap,
        required_level: u8,
        obj: &mut TestObject,
        new_value: u64
    ) {
        assert!(cap.admin_level >= required_level, E_UNAUTHORIZED);
        obj.value = new_value;
    }
    
    /// Test unauthorized access pattern - NEW!
    public fun test_unauthorized_access(
        has_permission: bool,
        obj: &mut TestObject,
        increment: u64
    ) {
        assert!(has_permission, E_UNAUTHORIZED);
        obj.value = obj.value + increment;
    }

    // ========================================
    // Category 5: Resource Safety (E_INSUFFICIENT_BALANCE: 103)
    // ========================================
    
    /// Coin must be consumed or returned
    public fun test_coin_handling(
        coin: Coin<SUI>,
        should_consume: bool,
        _ctx: &mut TxContext
    ): Option<Coin<SUI>> {
        if (should_consume) {
            // Destroy coin (converts to balance then drops)
            let balance = coin::into_balance(coin);
            balance::destroy_zero(balance);
            option::none()
        } else {
            // Return coin
            option::some(coin)
        }
    }
    
    /// Balance operations with abort (E_INSUFFICIENT_BALANCE: 103)
    public fun test_balance_split(
        obj: &mut TestObject,
        amount: u64
    ): Balance<SUI> {
        assert!(balance::value(&obj.balance) >= amount, E_INSUFFICIENT_BALANCE);
        balance::split(&mut obj.balance, amount)
    }
    
    /// Withdraw with insufficient balance check - NEW!
    public fun test_withdraw(
        obj: &mut TestObject,
        amount: u64,
        ctx: &mut TxContext
    ): Coin<SUI> {
        let balance_value = balance::value(&obj.balance);
        assert!(balance_value >= amount, E_INSUFFICIENT_BALANCE);
        
        let withdrawn = balance::split(&mut obj.balance, amount);
        coin::from_balance(withdrawn, ctx)
    }
    
    /// Minimum balance requirement - NEW!
    public fun test_minimum_balance(
        obj: &TestObject,
        minimum: u64
    ) {
        assert!(balance::value(&obj.balance) >= minimum, E_INSUFFICIENT_BALANCE);
    }
    
    /// Transfer with balance check - NEW!
    public fun test_transfer_with_check(
        from: &mut TestObject,
        to: &mut TestObject,
        amount: u64
    ) {
        // Check source has enough
        assert!(balance::value(&from.balance) >= amount, E_INSUFFICIENT_BALANCE);
        
        // Transfer
        let transferred = balance::split(&mut from.balance, amount);
        balance::join(&mut to.balance, transferred);
    }

    // ========================================
    // Category 6: Complex Multi-Step Scenarios
    // ========================================
    
    /// Multiple operations, abort at different points
    public fun test_multi_step(
        step_to_fail: u64,
        ctx: &mut TxContext
    ): vector<ID> {
        let mut ids = vector::empty<ID>();
        
        // Step 1
        let obj1 = TestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero()
        };
        vector::push_back(&mut ids, object::uid_to_inner(&obj1.id));
        transfer::share_object(obj1);
        assert!(step_to_fail != 1, E_INVALID_STATE);
        
        // Step 2
        let obj2 = TestObject {
            id: object::new(ctx),
            value: 200,
            balance: balance::zero()
        };
        vector::push_back(&mut ids, object::uid_to_inner(&obj2.id));
        transfer::share_object(obj2);
        assert!(step_to_fail != 2, E_INVALID_STATE);
        
        // Step 3
        let obj3 = TestObject {
            id: object::new(ctx),
            value: 300,
            balance: balance::zero()
        };
        vector::push_back(&mut ids, object::uid_to_inner(&obj3.id));
        transfer::share_object(obj3);
        assert!(step_to_fail != 3, E_INVALID_STATE);
        
        ids
    }
    
    /// Chain of operations on shared object
    public fun test_shared_object_chain(
        obj: &mut TestObject,
        operations: vector<u64>
    ) {
        let mut i = 0;
        while (i < vector::length(&operations)) {
            let op = *vector::borrow(&operations, i);
            
            if (op == 0) {
                obj.value = obj.value + 1;
            } else if (op == 1) {
                obj.value = obj.value - 1;  // May underflow
            } else if (op == 2) {
                obj.value = obj.value * 2;  // May overflow
            } else {
                abort E_INVALID_STATE
            };
            
            i = i + 1;
        }
    }
    
    /// Comprehensive validation (all error codes) - NEW!
    public fun test_comprehensive_validation(
        value: u64,
        balance_obj: &TestObject,
        required_balance: u64,
        has_permission: bool,
        min_value: u64,
        max_value: u64
    ) {
        // Check authorization first
        assert!(has_permission, E_UNAUTHORIZED);
        
        // Check value range
        assert!(value >= min_value, E_VALUE_TOO_SMALL);
        assert!(value <= max_value, E_VALUE_TOO_LARGE);
        
        // Check balance
        assert!(
            balance::value(&balance_obj.balance) >= required_balance,
            E_INSUFFICIENT_BALANCE
        );
        
        // All checks passed
    }

    // ========================================
    // Utility Functions
    // ========================================
    
    /// Get object value (for observation)
    public fun get_value(obj: &TestObject): u64 {
        obj.value
    }
    
    /// Get object balance (for observation)
    public fun get_balance(obj: &TestObject): u64 {
        balance::value(&obj.balance)
    }
    
    /// Destroy test object (for cleanup)
    public fun destroy_object(obj: TestObject) {
        let TestObject { id, value: _, balance } = obj;
        object::delete(id);
        balance::destroy_zero(balance);
    }
}