module abort_test::taxonomy {
    use sui::coin::{Self, Coin};
    use sui::sui::SUI;
    use sui::balance::{Self, Balance};

    // ========================================
    // Error Codes
    // ========================================
    
    const E_VALUE_TOO_SMALL: u64 = 100;
    const E_INVALID_STATE: u64 = 102;

    // ========================================
    // Test Objects: Owned vs Shared
    // ========================================
    
    /// Owned Object (single owner)
    public struct OwnedTestObject has key, store {
        id: UID,
        value: u64,
        balance: Balance<SUI>
    }
    
    /// Shared Object (globally accessible)
    public struct SharedTestObject has key {
        id: UID,
        value: u64,
        balance: Balance<SUI>
    }

    // ========================================
    // Category 1: Language-Level Errors with Depth
    // OWNED VERSION
    // ========================================
    
    /// Early abort (baseline - ~5 instructions)
    public fun test_owned_early_abort(value: u64) {
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    /// Shallow abort (~50 instructions before abort)
    public fun test_owned_shallow_abort(value: u64) {
        let _ = light_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    /// Medium abort (~200 instructions before abort)
    public fun test_owned_medium_abort(value: u64) {
        let _ = medium_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    /// Deep abort (~500 instructions before abort)
    public fun test_owned_deep_abort(value: u64) {
        let _ = heavy_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    // ========================================
    // Category 1: Language-Level Errors with Depth
    // SHARED VERSION
    // ========================================
    
    /// Early abort (baseline - ~5 instructions)
    public fun test_shared_early_abort(value: u64) {
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    /// Shallow abort (~50 instructions before abort)
    public fun test_shared_shallow_abort(value: u64) {
        let _ = light_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    /// Medium abort (~200 instructions before abort)
    public fun test_shared_medium_abort(value: u64) {
        let _ = medium_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    /// Deep abort (~500 instructions before abort)
    public fun test_shared_deep_abort(value: u64) {
        let _ = heavy_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    // ========================================
    // Category 2: VM-Level Errors
    // OWNED VERSION
    // ========================================
    
    /// Arithmetic overflow - Owned
    public fun test_overflow_owned(a: u64, b: u64): u64 {
        a + b
    }
    
    /// Division by zero - Owned
    public fun test_division_by_zero_owned(a: u64, b: u64): u64 {
        a / b
    }
    
    /// Vector out of bounds - Owned
    public fun test_vector_oob_owned(index: u64): u64 {
        let vec = vector[10u64, 20u64, 30u64];
        *vector::borrow(&vec, index)
    }

    // ========================================
    // Category 2: VM-Level Errors
    // SHARED VERSION
    // ========================================
    
    /// Arithmetic overflow - Shared
    public fun test_overflow_shared(a: u64, b: u64): u64 {
        a + b
    }
    
    /// Division by zero - Shared
    public fun test_division_by_zero_shared(a: u64, b: u64): u64 {
        a / b
    }
    
    /// Vector out of bounds - Shared
    public fun test_vector_oob_shared(index: u64): u64 {
        let vec = vector[10u64, 20u64, 30u64];
        *vector::borrow(&vec, index)
    }

    // ========================================
    // Category 3: State Rollback with Objects
    // OWNED VERSION
    // ========================================
    
    /// Create owned object and conditionally abort
    #[allow(lint(self_transfer))]
    public fun test_owned_object_creation(
        should_abort: bool,
        ctx: &mut TxContext
    ) {
        let obj = OwnedTestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero()
        };
        
        // Transfer to sender (Owned)
        transfer::transfer(obj, tx_context::sender(ctx));
        
        // Conditionally abort
        assert!(!should_abort, E_INVALID_STATE);
    }
    
    /// Modify owned object value
    /// Note: We must destroy and recreate due to UID uniqueness rules
    #[allow(lint(self_transfer))]
    public fun test_owned_object_modify(
        obj: OwnedTestObject,
        new_value: u64,
        should_abort: bool,
        ctx: &mut TxContext
    ) {
        // Extract old values and destroy
        let OwnedTestObject { id, value: _, balance } = obj;
        object::delete(id);
        
        // Create new object with modified value
        let modified = OwnedTestObject {
            id: object::new(ctx),
            value: new_value,
            balance
        };
        
        transfer::transfer(modified, tx_context::sender(ctx));
        
        assert!(!should_abort, E_INVALID_STATE);
    }

    // ========================================
    // Category 3: State Rollback with Objects
    // SHARED VERSION
    // ========================================
    
    /// Create shared object and conditionally abort
    public fun test_shared_object_creation(
        should_abort: bool,
        ctx: &mut TxContext
    ) {
        let obj = SharedTestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero()
        };
        
        // Share object (Shared)
        transfer::share_object(obj);
        
        // Conditionally abort
        assert!(!should_abort, E_INVALID_STATE);
    }
    
    /// Modify shared object value
    public fun test_shared_object_modify(
        obj: &mut SharedTestObject,
        new_value: u64,
        should_abort: bool
    ) {
        obj.value = new_value;
        
        assert!(!should_abort, E_INVALID_STATE);
    }

    // ========================================
    // Category 4: Balance Operations
    // OWNED VERSION
    // ========================================
    
    /// Test balance operations with owned object
    #[allow(lint(self_transfer))]
    public fun test_balance_owned(
        obj: OwnedTestObject,
        deposit: Coin<SUI>,
        should_abort: bool,
        ctx: &mut TxContext
    ) {
        // Extract values and destroy
        let OwnedTestObject { id, value, mut balance } = obj;
        object::delete(id);
        
        // Add coin to balance
        balance::join(&mut balance, coin::into_balance(deposit));
        
        // Conditionally abort
        assert!(!should_abort, E_INVALID_STATE);
        
        // Create new object with modified balance
        let modified = OwnedTestObject { 
            id: object::new(ctx), 
            value, 
            balance 
        };
        transfer::transfer(modified, tx_context::sender(ctx));
    }

    // ========================================
    // Category 4: Balance Operations
    // SHARED VERSION
    // ========================================
    
    /// Test balance operations with shared object
    public fun test_balance_shared(
        obj: &mut SharedTestObject,
        deposit: Coin<SUI>,
        should_abort: bool
    ) {
        // Add coin to balance
        balance::join(&mut obj.balance, coin::into_balance(deposit));
        
        // Conditionally abort
        assert!(!should_abort, E_INVALID_STATE);
    }

    // ========================================
    // Category 5: Storage Rebate Trap
    // ========================================

    /// Success case: Object cleanup with rebate
    public fun test_rebate_success_owned(
        ctx: &mut TxContext
    ) {
        // Create object
        let obj = create_owned_test_object(ctx);
        
        // Heavy computation
        let _ = heavy_computation(obj.value);
        
        // Destroy object → Storage rebate expected
        destroy_owned_object(obj);
    }

    /// Abort case: Object cleanup without rebate
    public fun test_rebate_abort_owned(
        ctx: &mut TxContext
    ) {
        // Create object
        let obj = create_owned_test_object(ctx);
        
        // Heavy computation
        let _ = heavy_computation(obj.value);
        
        // Destroy object (this executes but...)
        destroy_owned_object(obj);
        
        // Abort → All rollback → NO REBATE
        assert!(false, E_INVALID_STATE);
    }

    // ========================================
    // Category 6: Rollback Depth Analysis
    // ========================================

    /// Shallow rollback (1 state change)
    #[allow(lint(self_transfer))]
    public fun test_rollback_shallow_owned(
        ctx: &mut TxContext
    ) {
        let obj = create_owned_test_object(ctx);
        transfer::transfer(obj, tx_context::sender(ctx));
        assert!(false, E_INVALID_STATE);
    }

    /// Medium rollback (5 state changes)
    #[allow(lint(self_transfer))]
    public fun test_rollback_medium_owned(
        ctx: &mut TxContext
    ) {
        let obj1 = create_owned_test_object(ctx);
        let obj2 = create_owned_test_object(ctx);
        let obj3 = create_owned_test_object(ctx);
        let obj4 = create_owned_test_object(ctx);
        let obj5 = create_owned_test_object(ctx);
        
        transfer::transfer(obj1, tx_context::sender(ctx));
        transfer::transfer(obj2, tx_context::sender(ctx));
        transfer::transfer(obj3, tx_context::sender(ctx));
        transfer::transfer(obj4, tx_context::sender(ctx));
        transfer::transfer(obj5, tx_context::sender(ctx));
        
        assert!(false, E_INVALID_STATE);
    }

    /// Deep rollback (10 state changes)
    #[allow(lint(self_transfer))]
    public fun test_rollback_deep_owned(
        ctx: &mut TxContext
    ) {
        let obj1 = create_owned_test_object(ctx);
        let obj2 = create_owned_test_object(ctx);
        let obj3 = create_owned_test_object(ctx);
        let obj4 = create_owned_test_object(ctx);
        let obj5 = create_owned_test_object(ctx);
        let obj6 = create_owned_test_object(ctx);
        let obj7 = create_owned_test_object(ctx);
        let obj8 = create_owned_test_object(ctx);
        let obj9 = create_owned_test_object(ctx);
        let obj10 = create_owned_test_object(ctx);
        
        transfer::transfer(obj1, tx_context::sender(ctx));
        transfer::transfer(obj2, tx_context::sender(ctx));
        transfer::transfer(obj3, tx_context::sender(ctx));
        transfer::transfer(obj4, tx_context::sender(ctx));
        transfer::transfer(obj5, tx_context::sender(ctx));
        transfer::transfer(obj6, tx_context::sender(ctx));
        transfer::transfer(obj7, tx_context::sender(ctx));
        transfer::transfer(obj8, tx_context::sender(ctx));
        transfer::transfer(obj9, tx_context::sender(ctx));
        transfer::transfer(obj10, tx_context::sender(ctx));
        
        assert!(false, E_INVALID_STATE);
    }

    // ========================================
    // Setup Functions
    // ========================================
    
    /// Create owned test object (for reuse)
    public fun create_owned_test_object(
        ctx: &mut TxContext
    ): OwnedTestObject {
        OwnedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero()
        }
    }
    
    /// Create shared test object (for reuse)
    public fun create_shared_test_object(
        ctx: &mut TxContext
    ) {
        let obj = SharedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero()
        };
        transfer::share_object(obj);
    }
    
    /// Destroy owned object
    public fun destroy_owned_object(obj: OwnedTestObject) {
        let OwnedTestObject { id, value: _, balance } = obj;
        object::delete(id);
        balance::destroy_zero(balance);
    }

    // ========================================
    // Computation Load Helpers
    // ========================================

    /// Light computation (~50 instructions)
    fun light_computation(value: u64): u64 {
        let mut result = value;
        let mut i = 0;
        while (i < 10) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }

    /// Medium computation (~200 instructions)
    fun medium_computation(value: u64): u64 {
        let mut result = value;
        let mut i = 0;
        while (i < 50) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }

    /// Heavy computation (~500 instructions)
    fun heavy_computation(value: u64): u64 {
        let mut result = value;
        let mut i = 0;
        while (i < 200) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }
}