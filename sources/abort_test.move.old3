module abort_test::taxonomy {
    //use std::vector;

    use sui::balance::{Self, Balance};
    use sui::coin::{Self, Coin};
    use sui::sui::SUI;

    // ========================================
    // Error Codes
    // ========================================

    const E_VALUE_TOO_SMALL: u64 = 100;
    const E_INVALID_STATE: u64 = 102;

    // ========================================
    // Test Objects: Owned vs Shared
    // ========================================

    /// Owned Object (single owner)
    public struct OwnedTestObject has key, store {
        id: UID,
        value: u64,
        balance: Balance<SUI>,
        payload: vector<u8>,
    }

    /// Shared Object (globally accessible)
    public struct SharedTestObject has key {
        id: UID,
        value: u64,
        balance: Balance<SUI>,
        payload: vector<u8>,
    }

    // ========================================
    // Category 1: Language-Level Errors with Depth
    // OWNED
    // ========================================

    public fun test_owned_early_abort(value: u64) {
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    public fun test_owned_shallow_abort(value: u64) {
        let _ = light_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    public fun test_owned_medium_abort(value: u64) {
        let _ = medium_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    public fun test_owned_deep_abort(value: u64) {
        let _ = heavy_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    // ========================================
    // Category 1: Language-Level Errors with Depth
    // SHARED
    // ========================================

    public fun test_shared_early_abort(value: u64) {
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    public fun test_shared_shallow_abort(value: u64) {
        let _ = light_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    public fun test_shared_medium_abort(value: u64) {
        let _ = medium_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    public fun test_shared_deep_abort(value: u64) {
        let _ = heavy_computation(value);
        assert!(value > 100, E_VALUE_TOO_SMALL);
    }

    // ========================================
    // Category 2: VM-Level Errors (Owned/Shared)
    // ========================================

    public fun test_overflow_owned(a: u64, b: u64): u64 { a + b }
    public fun test_division_by_zero_owned(a: u64, b: u64): u64 { a / b }
    public fun test_vector_oob_owned(index: u64): u64 {
        let vec = vector[10u64, 20u64, 30u64];
        *vector::borrow(&vec, index)
    }

    public fun test_overflow_shared(a: u64, b: u64): u64 { a + b }
    public fun test_division_by_zero_shared(a: u64, b: u64): u64 { a / b }
    public fun test_vector_oob_shared(index: u64): u64 {
        let vec = vector[10u64, 20u64, 30u64];
        *vector::borrow(&vec, index)
    }

    // ========================================
    // Category 3: State Rollback with Objects
    // ========================================

    #[allow(lint(self_transfer))]
    public fun test_owned_object_creation(should_abort: bool, ctx: &mut TxContext) {
        let obj = OwnedTestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        };
        transfer::transfer(obj, tx_context::sender(ctx));
        assert!(!should_abort, E_INVALID_STATE);
    }

    #[allow(lint(self_transfer))]
    public fun test_owned_object_modify(
        obj: OwnedTestObject,
        new_value: u64,
        should_abort: bool,
        ctx: &mut TxContext
    ) {
        let OwnedTestObject { id, value: _, balance, payload } = obj;
        object::delete(id);

        let modified = OwnedTestObject {
            id: object::new(ctx),
            value: new_value,
            balance,
            payload,
        };

        transfer::transfer(modified, tx_context::sender(ctx));
        assert!(!should_abort, E_INVALID_STATE);
    }

    public fun test_shared_object_creation(should_abort: bool, ctx: &mut TxContext) {
        let obj = SharedTestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        };
        transfer::share_object(obj);
        assert!(!should_abort, E_INVALID_STATE);
    }

    public fun test_shared_object_modify(obj: &mut SharedTestObject, new_value: u64, should_abort: bool) {
        obj.value = new_value;
        assert!(!should_abort, E_INVALID_STATE);
    }

    // ========================================
    // Category 4: Balance Operations
    // ========================================

    #[allow(lint(self_transfer))]
    public fun test_balance_owned(
        obj: OwnedTestObject,
        deposit: Coin<SUI>,
        should_abort: bool,
        ctx: &mut TxContext
    ) {
        let OwnedTestObject { id, value, mut balance, payload } = obj;
        object::delete(id);

        balance::join(&mut balance, coin::into_balance(deposit));

        assert!(!should_abort, E_INVALID_STATE);

        let modified = OwnedTestObject {
            id: object::new(ctx),
            value,
            balance,
            payload,
        };
        transfer::transfer(modified, tx_context::sender(ctx));
    }

    public fun test_balance_shared(obj: &mut SharedTestObject, deposit: Coin<SUI>, should_abort: bool) {
        balance::join(&mut obj.balance, coin::into_balance(deposit));
        assert!(!should_abort, E_INVALID_STATE);
    }

    // ========================================
    // Category 5: Storage Rebate Trap
    // ========================================

    public fun test_rebate_success_owned(ctx: &mut TxContext) {
        let obj = create_owned_test_object(ctx);
        let _ = heavy_computation(obj.value);
        destroy_owned_object(obj);
    }

    public fun test_rebate_abort_owned(ctx: &mut TxContext) {
        let obj = create_owned_test_object(ctx);
        let _ = heavy_computation(obj.value);
        destroy_owned_object(obj);
        assert!(false, E_INVALID_STATE);
    }

    // ========================================
    // Category 6: Rollback Depth Analysis
    // ========================================

    #[allow(lint(self_transfer))]
    public fun test_rollback_shallow_owned(ctx: &mut TxContext) {
        let obj = create_owned_test_object(ctx);
        transfer::transfer(obj, tx_context::sender(ctx));
        assert!(false, E_INVALID_STATE);
    }

    #[allow(lint(self_transfer))]
    public fun test_rollback_medium_owned(ctx: &mut TxContext) {
        let obj1 = create_owned_test_object(ctx);
        let obj2 = create_owned_test_object(ctx);
        let obj3 = create_owned_test_object(ctx);
        let obj4 = create_owned_test_object(ctx);
        let obj5 = create_owned_test_object(ctx);

        transfer::transfer(obj1, tx_context::sender(ctx));
        transfer::transfer(obj2, tx_context::sender(ctx));
        transfer::transfer(obj3, tx_context::sender(ctx));
        transfer::transfer(obj4, tx_context::sender(ctx));
        transfer::transfer(obj5, tx_context::sender(ctx));

        assert!(false, E_INVALID_STATE);
    }

    #[allow(lint(self_transfer))]
    public fun test_rollback_deep_owned(ctx: &mut TxContext) {
        let obj1 = create_owned_test_object(ctx);
        let obj2 = create_owned_test_object(ctx);
        let obj3 = create_owned_test_object(ctx);
        let obj4 = create_owned_test_object(ctx);
        let obj5 = create_owned_test_object(ctx);
        let obj6 = create_owned_test_object(ctx);
        let obj7 = create_owned_test_object(ctx);
        let obj8 = create_owned_test_object(ctx);
        let obj9 = create_owned_test_object(ctx);
        let obj10 = create_owned_test_object(ctx);

        transfer::transfer(obj1, tx_context::sender(ctx));
        transfer::transfer(obj2, tx_context::sender(ctx));
        transfer::transfer(obj3, tx_context::sender(ctx));
        transfer::transfer(obj4, tx_context::sender(ctx));
        transfer::transfer(obj5, tx_context::sender(ctx));
        transfer::transfer(obj6, tx_context::sender(ctx));
        transfer::transfer(obj7, tx_context::sender(ctx));
        transfer::transfer(obj8, tx_context::sender(ctx));
        transfer::transfer(obj9, tx_context::sender(ctx));
        transfer::transfer(obj10, tx_context::sender(ctx));

        assert!(false, E_INVALID_STATE);
    }

    // ========================================
    // Category 7: Payload Sweep (NEW)
    // ========================================

    /// Create an owned object with payload and transfer to sender (persists on-chain)
    #[allow(lint(self_transfer))]
    public fun payload_create_owned(len: u64, ctx: &mut TxContext) {
        let obj = create_owned_test_object_with_payload(len, ctx);
        transfer::transfer(obj, tx_context::sender(ctx));
    }

    /// Create + destroy in same transaction (should get rebate)
    public fun payload_create_destroy_owned(len: u64, ctx: &mut TxContext) {
        let obj = create_owned_test_object_with_payload(len, ctx);
        destroy_owned_object(obj);
    }

    /// Create a shared object with payload (persists as shared on-chain)
    public fun payload_create_shared(len: u64, ctx: &mut TxContext) {
        let obj = create_shared_test_object_with_payload(len, ctx);
        transfer::share_object(obj);
    }

    // ========================================
    // Setup Functions
    // ========================================

    public fun create_owned_test_object(ctx: &mut TxContext): OwnedTestObject {
        OwnedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        }
    }

    public fun create_shared_test_object(ctx: &mut TxContext) {
        let obj = SharedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        };
        transfer::share_object(obj);
    }

    public fun destroy_owned_object(obj: OwnedTestObject) {
        let OwnedTestObject { id, value: _, balance, payload: _ } = obj;
        object::delete(id);
        balance::destroy_zero(balance);
    }

    public fun create_owned_test_object_with_payload(len: u64, ctx: &mut TxContext): OwnedTestObject {
        let mut payload = vector::empty<u8>();
        let mut i: u64 = 0;
        while (i < len) {
            vector::push_back(&mut payload, 0u8);
            i = i + 1;
        };

        OwnedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload,
        }
    }

    public fun create_shared_test_object_with_payload(len: u64, ctx: &mut TxContext): SharedTestObject {
        let mut payload = vector::empty<u8>();
        let mut i: u64 = 0;
        while (i < len) {
            vector::push_back(&mut payload, 0u8);
            i = i + 1;
        };

        SharedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload,
        }
    }

    // ========================================
    // Computation Load Helpers
    // ========================================

    fun light_computation(value: u64): u64 {
        let mut result = value;
        let mut i = 0;
        while (i < 10) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }

    fun medium_computation(value: u64): u64 {
        let mut result = value;
        let mut i = 0;
        while (i < 50) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }

    fun heavy_computation(value: u64): u64 {
        let mut result = value;
        let mut i = 0;
        while (i < 200) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }
}
