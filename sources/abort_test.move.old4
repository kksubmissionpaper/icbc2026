module aborttest::taxonomy {

    use sui::object::{Self, UID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};

    use sui::balance::{Self, Balance};
    use sui::coin::{Self, Coin};
    use sui::sui::SUI;

    /// Error Codes
    const EVALUETOOSMALL: u64 = 100;
    const EINVALIDSTATE: u64 = 102;

    /// Synthetic "research" code for explicit abort markers
    const EREBATE_EXPERIMENT: u64 = 999;

    /// Owned Object (single owner)
    public struct OwnedTestObject has key, store {
        id: UID,
        value: u64,
        balance: Balance<SUI>,
        payload: vector<u8>,
    }

    /// Shared Object (globally accessible)
    public struct SharedTestObject has key {
        id: UID,
        value: u64,
        balance: Balance<SUI>,
        payload: vector<u8>,
    }

    /***********************
     * Category 1: Language-Level Errors with Depth (OWNED)
     ***********************/
    public fun test_owned_early_abort(value: u64) {
        assert!(value >= 100, EVALUETOOSMALL);
    }

    public fun test_owned_shallow_abort(value: u64) {
        let _ = light_computation(value);
        assert!(value >= 100, EVALUETOOSMALL);
    }

    public fun test_owned_medium_abort(value: u64) {
        let _ = medium_computation(value);
        assert!(value >= 100, EVALUETOOSMALL);
    }

    public fun test_owned_deep_abort(value: u64) {
        let _ = heavy_computation(value);
        assert!(value >= 100, EVALUETOOSMALL);
    }

    /***********************
     * Category 1: Language-Level Errors with Depth (SHARED)
     ***********************/
    public fun test_shared_early_abort(value: u64) {
        assert!(value >= 100, EVALUETOOSMALL);
    }

    public fun test_shared_shallow_abort(value: u64) {
        let _ = light_computation(value);
        assert!(value >= 100, EVALUETOOSMALL);
    }

    public fun test_shared_medium_abort(value: u64) {
        let _ = medium_computation(value);
        assert!(value >= 100, EVALUETOOSMALL);
    }

    public fun test_shared_deep_abort(value: u64) {
        let _ = heavy_computation(value);
        assert!(value >= 100, EVALUETOOSMALL);
    }

    /***********************
     * Category 2: VM-Level Errors (OWNED/SHARED)
     ***********************/
    public fun test_overflow_owned(a: u64, b: u64): u64 { a + b }
    public fun test_division_by_zero_owned(a: u64, b: u64): u64 { a / b }

    public fun test_vector_oob_owned(index: u64): u64 {
        let v = vector[10u64, 20u64, 30u64];
        *vector::borrow(&v, index)
    }

    public fun test_overflow_shared(a: u64, b: u64): u64 { a + b }
    public fun test_division_by_zero_shared(a: u64, b: u64): u64 { a / b }

    public fun test_vector_oob_shared(index: u64): u64 {
        let v = vector[10u64, 20u64, 30u64];
        *vector::borrow(&v, index)
    }

    /***********************
     * Category 3: State Rollback with Objects
     ***********************/
    #[allow(lint(self_transfer))]
    public fun test_owned_object_creation(should_abort: bool, ctx: &mut TxContext) {
        let obj = OwnedTestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        };
        transfer::transfer(obj, tx_context::sender(ctx));
        assert!(!should_abort, EINVALIDSTATE);
    }

    #[allow(lint(self_transfer))]
    public fun test_owned_object_modify(obj: OwnedTestObject, new_value: u64, should_abort: bool, ctx: &mut TxContext) {
        let OwnedTestObject { id, value: _, balance, payload } = obj;
        object::delete(id);

        let modified = OwnedTestObject {
            id: object::new(ctx),
            value: new_value,
            balance,
            payload,
        };
        transfer::transfer(modified, tx_context::sender(ctx));
        assert!(!should_abort, EINVALIDSTATE);
    }

    public fun test_shared_object_creation(should_abort: bool, ctx: &mut TxContext) {
        let obj = SharedTestObject {
            id: object::new(ctx),
            value: 100,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        };
        transfer::share_object(obj);
        assert!(!should_abort, EINVALIDSTATE);
    }

    public fun test_shared_object_modify(obj: &mut SharedTestObject, new_value: u64, should_abort: bool) {
        obj.value = new_value;
        assert!(!should_abort, EINVALIDSTATE);
    }

    /***********************
     * Category 4: Balance Operations
     ***********************/
    #[allow(lint(self_transfer))]
    public fun test_balance_owned(obj: OwnedTestObject, deposit: Coin<SUI>, should_abort: bool, ctx: &mut TxContext) {
        let OwnedTestObject { id, value, mut balance, payload } = obj;
        object::delete(id);

        balance::join(&mut balance, coin::into_balance(deposit));
        assert!(!should_abort, EINVALIDSTATE);

        let modified = OwnedTestObject {
            id: object::new(ctx),
            value,
            balance,
            payload,
        };
        transfer::transfer(modified, tx_context::sender(ctx));
    }

    public fun test_balance_shared(obj: &mut SharedTestObject, deposit: Coin<SUI>, should_abort: bool) {
        balance::join(&mut obj.balance, coin::into_balance(deposit));
        assert!(!should_abort, EINVALIDSTATE);
    }

    /***********************
     * Category 5: Storage Rebate Trap (FIXED)
     *
     * 目的:
     * - success: create -> destroy でリベート発生 (effects=success)
     * - destroy-then-abort: destroy を実行した後に abort (effects=failure)
     * - abort-before-destroy: destroy に到達しない abort (effects=failure)
     *
     * TS互換のため、既存の2関数名は残す:
     *   - test_rebate_success_owned
     *   - test_rebate_abort_owned  (※中身を「abort-before-destroy」に変更)
     *
     * 追加で比較用:
     *   - test_rebate_destroy_then_abort_owned
     ***********************/

    /// (success) create -> heavy computation -> destroy -> end
    public fun test_rebate_success_owned(ctx: &mut TxContext) {
        let obj = create_owned_test_object(ctx);
        let _ = heavy_computation(obj.value);
        destroy_owned_object(obj);
    }

    /// (failure) abort-before-destroy: ここでは destroy に到達しない
    public fun test_rebate_abort_owned(ctx: &mut TxContext) {
        let obj = create_owned_test_object(ctx);
        let _ = heavy_computation(obj.value);

        // 失敗を先に発生させ、destroy は到達不能にする
        assert!(false, EREBATE_EXPERIMENT);

        // Unreachable (kept to make intent explicit)
        destroy_owned_object(obj);
    }

    /// (failure) destroy-then-abort: destroy を実行した上で abort
    public fun test_rebate_destroy_then_abort_owned(ctx: &mut TxContext) {
        let obj = create_owned_test_object(ctx);
        let _ = heavy_computation(obj.value);

        // 先に destroy を実行
        destroy_owned_object(obj);

        // 直後にわざと失敗
        assert!(false, EREBATE_EXPERIMENT);
    }

    /***********************
     * Category 6: Rollback Depth Analysis (OWNED)
     ***********************/
    #[allow(lint(self_transfer))]
    public fun test_rollback_shallow_owned(ctx: &mut TxContext) {
        let obj = create_owned_test_object(ctx);
        transfer::transfer(obj, tx_context::sender(ctx));
        assert!(false, EINVALIDSTATE);
    }

    #[allow(lint(self_transfer))]
    public fun test_rollback_medium_owned(ctx: &mut TxContext) {
        let obj1 = create_owned_test_object(ctx);
        let obj2 = create_owned_test_object(ctx);
        let obj3 = create_owned_test_object(ctx);
        let obj4 = create_owned_test_object(ctx);
        let obj5 = create_owned_test_object(ctx);

        transfer::transfer(obj1, tx_context::sender(ctx));
        transfer::transfer(obj2, tx_context::sender(ctx));
        transfer::transfer(obj3, tx_context::sender(ctx));
        transfer::transfer(obj4, tx_context::sender(ctx));
        transfer::transfer(obj5, tx_context::sender(ctx));

        assert!(false, EINVALIDSTATE);
    }

    #[allow(lint(self_transfer))]
    public fun test_rollback_deep_owned(ctx: &mut TxContext) {
        let obj1 = create_owned_test_object(ctx);
        let obj2 = create_owned_test_object(ctx);
        let obj3 = create_owned_test_object(ctx);
        let obj4 = create_owned_test_object(ctx);
        let obj5 = create_owned_test_object(ctx);
        let obj6 = create_owned_test_object(ctx);
        let obj7 = create_owned_test_object(ctx);
        let obj8 = create_owned_test_object(ctx);
        let obj9 = create_owned_test_object(ctx);
        let obj10 = create_owned_test_object(ctx);

        transfer::transfer(obj1, tx_context::sender(ctx));
        transfer::transfer(obj2, tx_context::sender(ctx));
        transfer::transfer(obj3, tx_context::sender(ctx));
        transfer::transfer(obj4, tx_context::sender(ctx));
        transfer::transfer(obj5, tx_context::sender(ctx));
        transfer::transfer(obj6, tx_context::sender(ctx));
        transfer::transfer(obj7, tx_context::sender(ctx));
        transfer::transfer(obj8, tx_context::sender(ctx));
        transfer::transfer(obj9, tx_context::sender(ctx));
        transfer::transfer(obj10, tx_context::sender(ctx));

        assert!(false, EINVALIDSTATE);
    }

    /***********************
     * Category 7: Payload Sweep
     ***********************/
    #[allow(lint(self_transfer))]
    public fun payload_create_owned(len: u64, ctx: &mut TxContext) {
        let obj = create_owned_test_object_with_payload(len, ctx);
        transfer::transfer(obj, tx_context::sender(ctx));
    }

    public fun payload_create_destroy_owned(len: u64, ctx: &mut TxContext) {
        let obj = create_owned_test_object_with_payload(len, ctx);
        destroy_owned_object(obj);
    }

    public fun payload_create_shared(len: u64, ctx: &mut TxContext) {
        let obj = create_shared_test_object_with_payload(len, ctx);
        transfer::share_object(obj);
    }

    /***********************
     * Setup / Teardown helpers
     ***********************/
    public fun create_owned_test_object(ctx: &mut TxContext): OwnedTestObject {
        OwnedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        }
    }

    public fun create_shared_test_object(ctx: &mut TxContext) {
        let obj = SharedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload: vector::empty<u8>(),
        };
        transfer::share_object(obj);
    }

    public fun destroy_owned_object(obj: OwnedTestObject) {
        let OwnedTestObject { id, value: _, balance, payload: _ } = obj;
        object::delete(id);
        balance::destroy_zero(balance);
    }

    public fun create_owned_test_object_with_payload(len: u64, ctx: &mut TxContext): OwnedTestObject {
        let mut payload = vector::empty<u8>();
        let mut i: u64 = 0;
        while (i < len) {
            vector::push_back(&mut payload, 0u8);
            i = i + 1;
        };

        OwnedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload,
        }
    }

    public fun create_shared_test_object_with_payload(len: u64, ctx: &mut TxContext): SharedTestObject {
        let mut payload = vector::empty<u8>();
        let mut i: u64 = 0;
        while (i < len) {
            vector::push_back(&mut payload, 0u8);
            i = i + 1;
        };

        SharedTestObject {
            id: object::new(ctx),
            value: 0,
            balance: balance::zero(),
            payload,
        }
    }

    /***********************
     * Computation Load Helpers
     ***********************/
    fun light_computation(value: u64): u64 {
        let mut result = value;
        let mut i: u64 = 0;
        while (i < 10) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }

    fun medium_computation(value: u64): u64 {
        let mut result = value;
        let mut i: u64 = 0;
        while (i < 50) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }

    fun heavy_computation(value: u64): u64 {
        let mut result = value;
        let mut i: u64 = 0;
        while (i < 200) {
            result = result + i * 2;
            i = i + 1;
        };
        result
    }
}
